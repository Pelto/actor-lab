package com.jayway.leaderboard.actors;

import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Inbox;
import akka.actor.Props;
import akka.testkit.JavaTestKit;
import com.jayway.leaderboard.dto.AccessToken;
import com.jayway.leaderboard.dto.Level;
import com.jayway.leaderboard.dto.TopScores;
import com.jayway.leaderboard.messages.LoginUser;
import com.jayway.leaderboard.messages.ReportScore;
import com.jayway.leaderboard.messages.RequestTopScore;
import com.jayway.leaderboard.messages.UserVerifiedResponse;
import com.jayway.leaderboard.messages.VerifyUser;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import scala.concurrent.duration.Duration;

import java.util.concurrent.TimeUnit;

import static org.hamcrest.core.IsEqual.equalTo;
import static org.junit.Assert.assertThat;

public class GameTests {

    private ActorSystem system;

    private ActorRef gameActor;

    private ActorRef usersActor;

    @Before
    public void setupSystem() {
        this.system = ActorSystem.create("game");
        this.usersActor = system.actorOf(Props.create(UsersActor.class, 1000L));
        this.gameActor = system.actorOf(Props.create(GameActor.class, usersActor));
    }

    @After
    public void killSystem() {
        JavaTestKit.shutdownActorSystem(system);
    }

    @Test
    public void report_score_returns_no_message() {
        new JavaTestKit(system) {{
            new Within(duration("2 second")) {
                @Override
                protected void run() {
                    ActorRef gameActor = system.actorOf(Props.create(GameActor.class, getRef()));
                    gameActor.tell(new ReportScore(new Level("level"), 100, new AccessToken()), ActorRef.noSender());

                    // Expect the message to the user actor, just reply when we receive it
                    expectMsgClass(VerifyUser.class);
                    reply(UserVerifiedResponse.verified("test"));

                    expectNoMsg();
                }
            };
        }};
    }

    @Test
    public void asks_the_user_service_if_the_accesstoken_is_valid() {
        new JavaTestKit(system) {{
            new Within(duration("3 seconds")) {
                @Override
                protected void run() {
                    Level level = new Level("level");

                    ActorRef gameActor = system.actorOf(Props.create(GameActor.class, getRef()));
                    ReportScore message = new ReportScore(new Level("level"), 100, new AccessToken());

                    gameActor.tell(message, getRef());

                    // The user is verified with our user actor
                    VerifyUser verificationRequest = expectMsgClass(VerifyUser.class);
                    assertThat(verificationRequest.accessToken(), equalTo(message.accessToken()));

                    reply(UserVerifiedResponse.verified("mocked-user"));

                    // We sleep for a while to allow all our high scores to be processed.
                    // If you do block the game actor when you do the verification of the
                    // access token this won't matter. However if you choose to do a future
                    // instead then all the scores might not have been processed yet.
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    gameActor.tell(new RequestTopScore(level), getRef());
                    TopScores topScores = expectMsgClass(TopScores.class);

                    assertThat(topScores.scores().size(), equalTo(1));
                }
            };
        }};
    }

    @Test
    public void do_not_add_the_score_if_not_validated() {
        new JavaTestKit(system) {{
            new Within(duration("3 seconds")) {
                @Override
                protected void run() {
                    Level level = new Level("level");

                    // Use a access token that hasn't been generated by the user actor
                    ReportScore message = new ReportScore(level, 100, new AccessToken());

                    gameActor.tell(message, getRef());

                    // We sleep for a while to allow all our high scores to be processed.
                    // If you do block the game actor when you do the verification of the
                    // access token this won't matter. However if you choose to do a future
                    // instead then all the scores might not have been processed yet.
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    gameActor.tell(new RequestTopScore(level), getRef());
                    TopScores topScores = expectMsgClass(TopScores.class);

                    assertThat(topScores.scores().size(), equalTo(0));
                }
            };
        }};
    }

    @Test
    public void only_the_highest_score_per_user_is_saved() {
        new JavaTestKit(system) {{
            new Within(duration("3 seconds")) {
                @Override
                protected void run() {
                    Level level = new Level("level");

                    AccessToken token = generateAccessToken("test-user");

                    ReportScore lowScore = new ReportScore(level, 5, token);
                    ReportScore highScore = new ReportScore(level, 10, lowScore.accessToken());

                    gameActor.tell(lowScore, getRef());
                    gameActor.tell(highScore, getRef());
                    gameActor.tell(lowScore, getRef());

                    // We sleep for a while to allow all our high scores to be processed.
                    // If you do block the game actor when you do the verification of the
                    // access token this won't matter. However if you choose to do a future
                    // instead then all the scores might not have been processed yet.
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    gameActor.tell(new RequestTopScore(level), getRef());
                    TopScores topScores = expectMsgClass(TopScores.class);

                    assertThat(topScores.scores().size(), equalTo(1));
                    assertThat(topScores.scores().get(0).score(), equalTo(10));
                }
            };
        }};
    }

    @Test
    public void only_fifteen_highest_are_saved() {
        new JavaTestKit(system) {{
            new Within(duration("3 seconds")) {
                @Override
                protected void run() {
                    Level level = new Level("level");

                    for (int i = 0; i <= 20; i++) {
                        AccessToken token = generateAccessToken("user-" + i);
                        ReportScore message = new ReportScore(level, i, token);
                        gameActor.tell(message, getRef());
                    }

                    // We sleep for a while to allow all our high scores to be processed.
                    // If you do block the game actor when you do the verification of the
                    // access token this won't matter. However if you choose to do a future
                    // instead then all the scores might not have been processed yet.
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    gameActor.tell(new RequestTopScore(level), getRef());
                    TopScores topScores = expectMsgClass(TopScores.class);

                    assertThat(topScores.scores().size(), equalTo(15));
                    assertThat(topScores.scores().get(6).score(), equalTo(6));
                    assertThat(topScores.scores().get(20).score(), equalTo(20));
                }
            };
        }};
    }

    private AccessToken generateAccessToken(String user) {
        Inbox inbox = Inbox.create(system);
        inbox.send(usersActor, new LoginUser(user));

        return (AccessToken) inbox.receive(Duration.create(1, TimeUnit.SECONDS));
    }
}
